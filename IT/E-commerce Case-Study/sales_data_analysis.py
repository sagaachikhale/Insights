# -*- coding: utf-8 -*-
"""Sales_Data_Analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1krixKDo7hEpQVqF7dD8t-j0QkfLeNvhn
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import warnings
warnings.filterwarnings('ignore')
#

!pip install pyarrow

path = '/content/drive/MyDrive/Python Project Practise/sales analysis/Sales_data.ftr'
a = pd.read_feather(path)
a
#

a.info()
#

a.isnull()
#

a.isnull().sum()

a.dropna(inplace=True)
a.isnull().sum()
#

a[a.duplicated()]
#

a.drop_duplicates(inplace=True)
a[a.duplicated()]
#

# Try using the 'infer_datetime_format' parameter to let pandas guess the format
a['Order Date'] = pd.to_datetime(a['Order Date'], infer_datetime_format=True, errors='coerce')

# Inspect any dates that couldn't be parsed (they will be NaT - Not a Time)
a[a['Order Date'].isnull()]

a = a.dropna(how='any')

# Try using the 'infer_datetime_format' parameter to let pandas guess the format
a['Order Date'] = pd.to_datetime(a['Order Date'], infer_datetime_format=True, errors='coerce')

# Inspect any dates that couldn't be parsed (they will be NaT - Not a Time)
a[a['Order Date'].isnull()]

"""**Analyzing monthly sale**"""

a['Order Date'] = pd.to_datetime(a['Order Date'], format='%m/%d/%y') #reassuring date and time format

new_format = '%Y-%m-%d %H:%M' #new date and time format
a['Order Date'] = a['Order Date'].dt.strftime(new_format) #convert to new date and time format

a

a['Order Date'][0]

a['Order Date'][0].split(' ')[0].split('-')[1] #extract month

months = []
for i in a['Order Date']:
  months.append(i.split(' ')[0].split('-')[1])  #extracting months
a['Months'] = months #new column with months
a

a.dtypes

a['Months'] = a['Months'].astype(int)
a.dtypes

# to check the missing values
# Assuming 'a' is your DataFrame
missing_indices = a.index.difference(range(len(a)))

if len(missing_indices) == 0:
  print("There are no missing indices in your DataFrame.")
else:
  print("There are missing indices. You might not be seeing the entire DataFrame.")

a = a.reset_index(drop=True)
a

a['Quantity Ordered'] = a['Quantity Ordered'].astype(int)
a['Price Each'] = a['Price Each'].astype(float)
a.dtypes

a['Sales'] = a['Quantity Ordered'] * a['Price Each']
a

a.groupby(['Months'])['Sales'].sum()

a.groupby(['Months'])['Sales'].sum().plot(kind='bar')
plt.xlabel('Months')
plt.ylabel('Sales')
plt.show()

"""**Monthly sales in each city**"""

Cities1 = []
for i in a['Purchase Address']:
  Cities1.append(i.split(',')[1])
a['Cities'] = Cities1
a

"""**Monthly sales in each state**"""

State1 = []
for i in a['Purchase Address']:
  State1.append(i.split(',')[2].split(' ')[1])
a['State'] = State1
a

a.groupby(['Cities'])['Sales'].sum()

a.groupby(['Cities'])['Sales'].sum().plot(kind='bar')
plt.xlabel('Cities')
plt.ylabel('Sales')
plt.show()
#

a.groupby(['Cities'])['Sales'].sum().plot(kind='pie', autopct='%0.2f%%')
plt.xlabel('Cities')
plt.ylabel('Sales')
plt.show()
#

a.groupby(['State'])['Sales'].sum().plot(kind='bar')
plt.xlabel('State')
plt.ylabel('Sales')
plt.show()

pd.value_counts(a['Cities'])

pd.value_counts(a['Cities']).plot(kind='pie', autopct='%0.2f%%')
plt.show()
#

"""**Understanding which product sold the most and why?**"""

unique_product1 = a['Product'].unique()
unique_product1

unique_products_df = pd.DataFrame(unique_product1, columns=['Unique Products'])
unique_products_df

Quantiy_ordered1 = []
for i in a['Product'].unique():
  Quantiy_ordered1.append(a[a['Product'] == i]['Quantity Ordered'].sum())
unique_products_df['Quantities Ordered'] = Quantiy_ordered1
unique_products_df

a[a['Product'] == 'USB-C Charging Cable']['Price Each'].mean()

Price_each = []
for i in a['Product'].unique():
  Price_each.append(a[a['Product'] == i]['Price Each'].mean())
unique_products_df['Prices Each'] = Price_each
unique_products_df

#unique_products_df = unique_products_df.sort_values(by='Quantities Ordered', ascending=False)
#new_index = [f'P{i}' for i in range(1, len(unique_products_df) + 1)]
#unique_products_df.index = new_index
#unique_products_df

#a.groupby(['Product']).agg({'Quantity Ordered':'sum', 'Price Each':'mean'}) #using agg function

Products = a['Product'].unique()
Products

fig, ax1 = plt.subplots()
ax2 = ax1.twinx()

ax1.bar(unique_products_df['Unique Products'], unique_products_df['Quantities Ordered'], color='b')
ax2.plot(unique_products_df['Unique Products'], unique_products_df['Prices Each'], color='r')
ax1.set_xticklabels(Products, rotation = 'vertical')
ax1.set_xlabel('Unique Products')
ax1.set_ylabel('Quantities Ordered', color='b')
ax2.set_ylabel('Prices Each', color='r')

plt.show()
#

"""**Understanding the trend of most sold products**"""

#Creating pivot table
#understanding trend of the most sold products!

#trend = pd.crosstab(a['Months'], a['Product']) #Method 1
#trend

a['Product'].value_counts()[0:5].index

most_sold_products = a['Product'].value_counts()[0:5].index
most_sold_products

most_sold_products_df = a[a['Product'].isin(most_sold_products)]
most_sold_products_df

pivot = most_sold_products_df.groupby(['Months', 'Product']).size().unstack()
pivot
#

pivot.plot(figsize=(10,6))
plt.xlabel('Months')
plt.ylabel('Quantity Ordered')
plt.title('Trend of the most sold products')
plt.show()

a.columns

a.info()

a['Cities'].unique()

"""**Understanding which product sold the most in each city in every month of the year**"""

# Group by 'Cities', 'Months', and 'Product'
grouped_data = a.groupby(['Cities', 'Months', 'Product'])

# Calculate the sum of 'Quantity Ordered' for each group
total_quantity = grouped_data['Quantity Ordered'].sum().reset_index()

# Sort by 'Quantity Ordered' in descending order
sorted_data = total_quantity.sort_values(by='Quantity Ordered', ascending=False)

# Get the top-selling product for each city and month
# No changes needed here as 'Product' column is now included
top_products = sorted_data.groupby(['Cities', 'Months'])['Product'].first().reset_index()

# Print the results
print(top_products)

# Change the aggregation function to 'first' to get the first product for each cell
pivot_table1 = top_products.pivot_table(values='Product', index='Months', columns='Cities', aggfunc='first')

# Print the pivot table
print(pivot_table1)

"""**Understanding which product sold the least in each city in every month of the year**"""

# Group by 'Cities', 'Months', and 'Product'
grouped_data = a.groupby(['Cities', 'Months', 'Product'])

# Calculate the sum of 'Quantity Ordered' for each group
total_quantity = grouped_data['Quantity Ordered'].sum().reset_index()

# Sort by 'Quantity Ordered' in descending order
sorted_data = total_quantity.sort_values(by='Quantity Ordered', ascending=True)

# Get the lowest-selling product for each city and month
# No changes needed here as 'Product' column is now included
lowest_products = sorted_data.groupby(['Cities', 'Months'])['Product'].first().reset_index()

# Print the results
lowest_products

# Change the aggregation function to 'first' to get the first product for each cell
pivot_table2 = lowest_products.pivot_table(values='Product', index='Months', columns='Cities', aggfunc='first')

# Print the pivot table
print(pivot_table2)

#State wise and month wise see which top product sold

grouped_data = a.groupby(['State', 'Months', 'Product'])

# Calculate the sum of 'Quantity Ordered' for each group
total_quantity = grouped_data['Quantity Ordered'].sum().reset_index()

# Sort by 'Quantity Ordered' in descending order
sorted_data = total_quantity.sort_values(by='Quantity Ordered', ascending=False)

# Get the top-selling product for each city and month
# No changes needed here as 'Product' column is now included
state_top_products = sorted_data.groupby(['State', 'Months'])['Product'].first().reset_index()

# Print the results
state_top_products

pivot_table3 = state_top_products.pivot_table(values='Product', index='Months', columns='State', aggfunc='first')

# Print the pivot table
print(pivot_table3)

#State wise and month wise see which low product sold

grouped_data = a.groupby(['State', 'Months', 'Product'])

# Calculate the sum of 'Quantity Ordered' for each group
total_quantity = grouped_data['Quantity Ordered'].sum().reset_index()

# Sort by 'Quantity Ordered' in descending order
sorted_data = total_quantity.sort_values(by='Quantity Ordered', ascending=True)

# Get the lowest-selling product for each city and month
# No changes needed here as 'Product' column is now included
state_lowest_products = sorted_data.groupby(['State', 'Months'])['Product'].first().reset_index()

# Print the results
state_lowest_products

pivot_table4 = state_lowest_products.pivot_table(values='Product', index='Months', columns='State', aggfunc='first')

# Print the pivot table
print(pivot_table4)